# Program Loader

A program loader is the part of an [OS](https://embeddedartistry.com/fieldmanual-terms/operating-system/) that is responsible for loading programs and libraries for execution. 

In [computer systems](http://en.wikipedia.org/wiki/Computing "Computing") a **loader** is the part of an [operating system](http://en.wikipedia.org/wiki/Operating_system "Operating system") that is responsible for loading [programs](http://en.wikipedia.org/wiki/Computer_program "Computer program") and [libraries](http://en.wikipedia.org/wiki/Library_(computing) "Library (computing)"). It is one of the essential stages in the process of starting a program, as it places programs into memory and prepares them for execution. Loading a program involves reading the contents of the [executable file](http://en.wikipedia.org/wiki/Executable "Executable") containing the program instructions into memory, and then carrying out other required preparatory tasks to prepare the executable for running. Once loading is complete, the operating system starts the program by passing control to the loaded program code.

All operating systems that support program loading have loaders, apart from highly specialised computer systems that only have a fixed set of specialized programs. [Embedded systems](http://en.wikipedia.org/wiki/Embedded_system "Embedded system") typically do not have loaders, and instead, the code executes directly from ROM. In order to load the operating system itself, as part of [booting](http://en.wikipedia.org/wiki/Booting "Booting"), a specialised [boot loader](http://en.wikipedia.org/wiki/Boot_loader "Boot loader") is used. In many operating systems, the loader resides permanently in memory, though some operating systems that support [virtual memory](http://en.wikipedia.org/wiki/Virtual_memory "Virtual memory") may allow the loader to be located in a region of memory that is [pageable](http://en.wikipedia.org/wiki/Paging "Paging").

In the case of operating systems that support virtual memory, the loader may not actually copy the contents of executable files into memory, but rather may simply declare to the virtual memory subsystem that there is a mapping between a region of memory allocated to contain the running program's code and the contents of the associated executable file. (See [memory-mapped file](http://en.wikipedia.org/wiki/Memory-mapped_file "Memory-mapped file").) The virtual memory subsystem is then made aware that pages with that region of memory need to be filled on demand if and when program execution actually hits those areas of unfilled memory. This may mean parts of a program's code are not actually copied into memory until they are actually used, and unused code may never be loaded into memory at all.